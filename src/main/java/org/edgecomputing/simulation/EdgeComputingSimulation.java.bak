package org.edgecomputing.simulation;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Random;
import org.cloudbus.cloudsim.brokers.DatacenterBrokerSimple;
import org.cloudbus.cloudsim.core.CloudSim;
import org.edgecomputing.models.CloudDatacenter;
import org.edgecomputing.models.EdgeNode;
import org.edgecomputing.models.IoTDevice;
import org.edgecomputing.models.Task;
import org.edgecomputing.policies.EnergyAwareOffloadingPolicy;
import org.edgecomputing.policies.OffloadingPolicy;
import org.edgecomputing.policies.ServiceSlicingPolicy;
import org.edgecomputing.policies.TaskScheduler;
import org.edgecomputing.utils.SimulationResults;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Main simulation class for Edge Computing IoT project.
 * This class initializes the simulation environment, configures components,
 * and runs the simulation based on the paper:
 * "IoT Service Slicing and Task Offloading for Edge Computing"
 */
public class EdgeComputingSimulation {
    
    private static final Logger logger = LoggerFactory.getLogger(EdgeComputingSimulation.class);
    
    // Simulation configuration
    private JsonObject config;
    
    // Simulation components
    private List<IoTDevice> devices;
    private List<EdgeNode> edgeNodes;
    private CloudDatacenter cloudDatacenter;
    private OffloadingPolicy offloadingPolicy;
    private ServiceSlicingPolicy slicingPolicy;
    private TaskScheduler taskScheduler;
    
    // Simulation parameters
    private double simStartTime = 0.0;
    private double simEndTime = 3600.0; // Default 1 hour simulation
    private double timeStep = 0.1;      // Default 100ms time step
    private Random random;
    
    // Results
    private SimulationResults results;
    
    /**
     * Create and initialize the simulation.
     *
     * @param configFile Path to the simulation configuration JSON file
     * @throws IOException if the configuration file cannot be read
     */
    public EdgeComputingSimulation(String configFile) throws IOException {
        logger.info("Initializing Edge Computing Simulation");
        
        // Load configuration
        loadConfiguration(configFile);
        
        // Set random seed for reproducibility
        random = new Random(42);
        
        // Initialize components
        devices = new ArrayList<>();
        edgeNodes = new ArrayList<>();
        initializeComponents();
        
        // Create results tracker
        results = new SimulationResults();
        
        logger.info("Simulation initialized with {} IoT devices and {} edge nodes", 
                    devices.size(), edgeNodes.size());
    }
    
    /**
     * Load the simulation configuration from JSON file.
     *
     * @param configFile Path to the configuration file
     * @throws IOException if the file cannot be read
     */
    private void loadConfiguration(String configFile) throws IOException {
        logger.info("Loading configuration from {}", configFile);
        Gson gson = new Gson();
        try (FileReader reader = new FileReader(configFile)) {
            config = gson.fromJson(reader, JsonObject.class);
        }
        
        // Get simulation parameters
        if (config.has("simulation")) {
            JsonObject simConfig = config.getAsJsonObject("simulation");
            if (simConfig.has("durationSeconds")) {
                simEndTime = simConfig.get("duration").getAsDouble();
            }
            if (simConfig.has("timeStepSeconds")) {
                timeStep = simConfig.get("time_step").getAsDouble();
            }
        }
        
        logger.info("Simulation will run for {} seconds with time step of {} seconds",
                   simEndTime, timeStep);
    }
    
    /**
     * Initialize simulation components from configuration.
     */
    private void initializeComponents() {
        // Initialize offloading policy
        JsonObject policyConfig = config.getAsJsonObject("offloading_policy");
        offloadingPolicy = new EnergyAwareOffloadingPolicy(
                policyConfig.get("threshold_battery_level").getAsDouble(),
                policyConfig.get("threshold_task_size").getAsLong(),
                policyConfig.get("threshold_network_quality").getAsDouble(),
                policyConfig.get("weight_energy").getAsDouble(),
                policyConfig.get("weight_latency").getAsDouble(),
                policyConfig.get("weight_cost").getAsDouble()
        );
        
        // Initialize service slicing policy
        slicingPolicy = new ServiceSlicingPolicy();
        JsonObject slicesConfig = config.getAsJsonObject("service_slicing");
        JsonArray slicesArray = slicesConfig.getAsJsonArray("slices");
        for (int i = 0; i < slicesArray.size(); i++) {
            JsonObject sliceConfig = slicesArray.get(i).getAsJsonObject();
            String sliceName = sliceConfig.get("name").getAsString();
            slicingPolicy.addSliceConfiguration(
                    sliceName,
                    sliceConfig.get("resource_percentage").getAsDouble(),
                    sliceConfig.get("priority").getAsInt(),
                    gson().fromJson(sliceConfig.get("task_types"), List.class)
            );
        }
        
        // Initialize task scheduler
        taskScheduler = new TaskScheduler(offloadingPolicy, slicingPolicy);
        
        // Initialize edge nodes
        JsonObject edgeNodesConfig = config.getAsJsonObject("edge_nodes");
        int nodeIdCounter = 1;
        int totalNodeCount = edgeNodesConfig.get("count").getAsInt();
        JsonArray nodeTypes = edgeNodesConfig.getAsJsonArray("types");
        
        for (int typeIdx = 0; typeIdx < nodeTypes.size(); typeIdx++) {
            JsonObject typeConfig = nodeTypes.get(typeIdx).getAsJsonObject();
            String nodeType = typeConfig.get("name").getAsString();
            // Distribute nodes according to type ratio
            int count = Math.max(1, totalNodeCount / nodeTypes.size());
            
            for (int i = 0; i < count; i++) {
                EdgeNode node = new EdgeNode(
                        nodeIdCounter++,
                        "Edge-" + nodeType + "-" + i,
                        typeConfig.get("mips").getAsInt(),
                        typeConfig.get("ram").getAsInt(),
                        typeConfig.get("storage").getAsLong(),
                        typeConfig.get("bw").getAsLong(),
                        typeConfig.get("cost_per_mips").getAsDouble(),
                        random.nextDouble() * 1000,  // Random X location
                        random.nextDouble() * 1000   // Random Y location
                );
                
                // Apply service slicing to this node
                slicingPolicy.applySlicing(node);
                edgeNodes.add(node);
            }
        }
        
        // Initialize cloud datacenter
        JsonObject cloudConfig = config.getAsJsonObject("cloud");
        cloudDatacenter = new CloudDatacenter(
                1,
                "Cloud-DC",
                cloudConfig.get("mips").getAsInt(),
                cloudConfig.get("ram").getAsInt(),
                cloudConfig.get("storage").getAsLong(),
                cloudConfig.get("bandwidth").getAsLong(),
                cloudConfig.get("cost_per_mips").getAsDouble(),
                cloudConfig.get("latency_to_edge_ms").getAsDouble()
        );
        
        // Initialize IoT devices
        JsonObject deviceConfig = config.getAsJsonObject("iot_devices");
        int deviceIdCounter = 1;
        int totalDeviceCount = deviceConfig.get("count").getAsInt();
        JsonArray deviceTypes = deviceConfig.getAsJsonArray("types");
        
        for (int typeIdx = 0; typeIdx < deviceTypes.size(); typeIdx++) {
            JsonObject typeConfig = deviceTypes.get(typeIdx).getAsJsonObject();
            String deviceType = typeConfig.get("name").getAsString();
            // Distribute devices according to type ratio
            int count = Math.max(1, totalDeviceCount / deviceTypes.size());
            
            for (int i = 0; i < count; i++) {
                IoTDevice device = new IoTDevice(
                        deviceIdCounter++,
                        "Device-" + deviceType + "-" + i,
                        typeConfig.get("mips").getAsInt(),
                        typeConfig.get("ram").getAsInt(),
                        typeConfig.get("battery_capacity").getAsDouble(),
                        typeConfig.get("battery_consumption_rate").getAsDouble(),
                        typeConfig.get("wireless_technology").getAsString(),
                        typeConfig.get("task_generation_rate").getAsDouble(),
                        typeConfig.get("mobility").getAsBoolean(),
                        typeConfig.get("mobility_speed").getAsDouble(),
                        random.nextDouble() * 1000,  // Random X location
                        random.nextDouble() * 1000   // Random Y location
                );
                
                // Set network parameters
                String wirelessTech = typeConfig.get("wireless_technology").getAsString();
                JsonObject networkConfig = config.getAsJsonObject("network")
                                                .getAsJsonObject("technologies")
                                                .getAsJsonObject(wirelessTech);
                device.setNetworkParameters(
                        networkConfig.get("latency_ms").getAsDouble(),
                        networkConfig.get("bandwidth_mbps").getAsDouble(),
                        networkConfig.get("reliability").getAsDouble(),
                        networkConfig.get("energy_consumption").getAsDouble()
                );
                
                // Add supported task types
                if (typeConfig.has("supportedTaskTypes")) {
                    device.setSupportedTaskTypes(
                            gson().fromJson(typeConfig.get("supported_task_types"), List.class)
                    );
                } else {
                    // Default - support all task types
                    device.setSupportedTaskTypes(Arrays.asList("lightweight", "medium", "intensive"));
                }
                
                devices.add(device);
            }
        }
    }
    
    // Initialize components
    devices = new ArrayList<>();
    edgeNodes = new ArrayList<>();
    initializeComponents();
            
            // Generate new tasks from IoT devices
            for (IoTDevice device : devices) {
                List<Task> newTasks = device.generateTasks(currentTime, timeStep);
                for (Task task : newTasks) {
                    taskScheduler.submitTask(task);
                    totalTasksGenerated++;
                }
            }
            
            // Process task offloading and scheduling
            taskScheduler.schedulePendingTasks(devices, edgeNodes, cloudDatacenter, currentTime);
            
            // Update task status
            taskScheduler.updateTaskStatus(devices, edgeNodes, cloudDatacenter, currentTime);
            
            // Collect metrics at this time step
            collectMetrics(currentTime);
            
            // Advance simulation time
            currentTime += timeStep;
            
            // Print progress every 10% of simulation time
            if (Math.floor(currentTime / (simEndTime / 10)) > 
                Math.floor((currentTime - timeStep) / (simEndTime / 10))) {
                logger.info("Simulation {}% complete. Tasks generated: {}, Tasks completed: {}",
                           (int)(currentTime / simEndTime * 100),
                           totalTasksGenerated,
                           taskScheduler.getCompletedTaskCount());
            }
        }
        
        logger.info("Simulation completed. Total tasks: {}, Completed: {}, Pending: {}, Running: {}",
                   totalTasksGenerated,
                   taskScheduler.getCompletedTaskCount(),
                   taskScheduler.getPendingTaskCount(),
                   taskScheduler.getRunningTaskCount());
    }
    
    /**
     * Collect metrics at the current simulation time.
     *
     * @param currentTime The current simulation time
     */
    private void collectMetrics(double currentTime) {
        // Device metrics
        for (IoTDevice device : devices) {
            results.recordDeviceState(
                    currentTime, 
                    device.getDeviceId(), 
                    device.getBatteryLevel(), 
                    device.getTasksExecutedLocally(),
                    device.getTasksOffloaded());
        }
        
        // Edge node metrics
        for (EdgeNode node : edgeNodes) {
            results.recordEdgeNodeState(
                    currentTime,
                    node.getNodeId(),
                    node.getCpuUtilization(),
                    node.getRamUtilization(),
                    node.getBwUtilization(),
                    node.getActiveTaskCount(),
                    node.getTotalTasksProcessed());
        }
        
        // Cloud metrics
        results.recordCloudState(
                currentTime,
                cloudDatacenter.getCpuUtilization(),
                cloudDatacenter.getRamUtilization(),
                cloudDatacenter.getBwUtilization(),
                cloudDatacenter.getActiveTasks().size(),
                cloudDatacenter.getTotalTasksProcessed());
        
        // Task metrics
        if (taskScheduler.getCompletedTaskCount() > 0) {
            Map<String, Double> taskStats = taskScheduler.getTaskStatistics();
            results.recordTaskMetrics(
                    currentTime,
                    taskStats.getOrDefault("averageResponseTime", 0.0),
                    taskStats.getOrDefault("averageExecutionTime", 0.0),
                    taskStats.getOrDefault("averageEnergyConsumed", 0.0),
                    taskStats.getOrDefault("localTasks", 0.0).intValue(),
                    taskStats.getOrDefault("edgeTasks", 0.0).intValue(),
                    taskStats.getOrDefault("cloudTasks", 0.0).intValue(),
                    taskStats.getOrDefault("deadlineMetPercentage", 0.0));
        }
    }
    
    /**
     * Get the simulation results.
     *
     * @return The simulation results
     */
    public SimulationResults getResults() {
        return results;
    }
    
    /**
     * Export simulation results to CSV files.
     *
     * @param outputDir Directory to export results to
     * @throws IOException if there's an error writing the files
     */
    public void exportResults(String outputDir) throws IOException {
        logger.info("Exporting simulation results to {}", outputDir);
        
        // Create output directory if it doesn't exist
        Files.createDirectories(Paths.get(outputDir));
        
        // Export each type of result
        results.exportDeviceMetrics(outputDir + "/device_metrics.csv");
        results.exportEdgeNodeMetrics(outputDir + "/edge_metrics.csv");
        results.exportCloudMetrics(outputDir + "/cloud_metrics.csv");
        results.exportTaskMetrics(outputDir + "/task_metrics.csv");
        results.exportSummary(outputDir + "/summary.txt");
        
        logger.info("Export completed");
    }
    
    /**
     * Helper method to get Gson instance.
     */
    private Gson gson() {
        return new Gson();
    }
    
    /**
     * Main method to run the simulation.
     *
     * @param args Command-line arguments
     */
    public static void main(String[] args) {
        try {
            // Default config path
            String configPath = "src/main/resources/simulation_config.json";
            
            // Use config path from arguments if provided
            if (args.length > 0) {
                configPath = args[0];
            }
            
            // Default output directory
            String outputDir = "results";
            
            // Use output directory from arguments if provided
            if (args.length > 1) {
                outputDir = args[1];
            }
            
            logger.info("Starting Edge Computing Simulation");
            logger.info("Configuration: {}", configPath);
            logger.info("Output directory: {}", outputDir);
            
            // Create and run simulation
            EdgeComputingSimulation simulation = new EdgeComputingSimulation(configPath);
            simulation.runSimulation();
            
            // Export results
            simulation.exportResults(outputDir);
            
        } catch (Exception e) {
            logger.error("Error in simulation", e);
            e.printStackTrace();
        }
    }
}
